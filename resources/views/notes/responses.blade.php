@extends('master')

@section('content')
  <h1>HTTP Responses</h1>

  <h2>Creating Responses</h2>

  <h4>Strings and Arrays</h4>

  <p>All routes and controllers should return a promise to be sent back to the user's browser. Laravel provides several different ways to return a promise. The most basic response is simply returning a string from a route or controller. The framework will automatically turn the string into a full HTTP response:</p>

  <pre><code class="language-php">
    Route::get('/', function() {
      return 'Hello World!';
    });
  </code></pre>

  <p>In addition to returning strings from the routes and controllers, we can also return arrays. The framework will automaticaly convert the array into a JSON response:</p>

  <pre><code class="language-php">
    Route::get('/', function() {
      return [1, 2, 3];
    });
  </code></pre>

  <div class="w3-panel w3-border-blue w3-leftbar w3-pale-blue">
    <p>We can also return Eloquent Collections from the routes and controllers. They will automatically be converted to JSON.</p>
  </div>

  <h4>Response Objects</h4>

  <p>Typically we won't be just returning simple strings or arrays from your route actions. Instead we will be returning full Illuminate\Http\Response instances or views.</p>

  <p>Returning a full Response instance allows you to customize the response's HTTP status code and headers. A Response instance inherits from the Symfony\Component\HttpFoundation\Response class, which provides a variety of methods for building HTTP responses:</p>

  <pre><code class="language-php">
    Route::get('home', function() {
      return response('Hello World', 200)
      ->header('Content-Type', 'text/plain');
    });
  </code></pre>

  <h4>Attaching Headers to Responses</h4>

  <p>Keep in mind that most response methods are chainable, allowing for the fluent construction of response instances. For example, we can use the header() method to add a series of headers to the response before sending it back to the user:</p>

  <pre><code class="language-php">
    return response($content)
      ->header('Content-Type', $type)
      ->header('X-Header-One', 'Header Value')
      ->header('X-Header-Two', 'Header Value');
  </code></pre>

  <p>Or we can use the withHeaders() method to specify an array of headers to be added to the response:</p>

  <pre><code class="language-php">
    return response($content)
      ->withHeaders([
        'Content-Type' => $type,
        'X-Header-One' => 'Header Value'
        'X-Header-Two' => 'Header Value'
      ]);
  </code></pre>

  <h4>Attaching Cookies to Responses</h4>

  <p>The cookie() method on response instances allows us to easily attach cookies to the response. For example, we can use the cookie() method to generate a cookie and fluently attach it to the response instance like so:</p>

  <pre><code class="language-php">
    return response($content)
      ->header('Content-Type', $type)
      ->cookie('name', 'value', $minutes);
  </code></pre>

  <p>The cookie() method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native setcookie() method:</p>

  <pre><code class="language-php">
    ->cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly)
  </code></pre>

  <h4>Cookies and Encryption</h4>

  <p>By default, all cookies generated by Laravel are encrypted and signed so that they can't be modified or read by the client. To disable cookie encryption for a subset of cookies generated by the application, we can use the $except property of the App\Http\Middleware\EncryptCookies middleware, which is located in the app/Http/Middleware directory:</p>

  <pre><code class="language-php">
    /**
     * The names of the cookies that should not be encrypted.
     *
     * @var array
     */
    protected $except = [
        'cookie_name',
    ];
  </code></pre>

  <h2>Redirects</h2>

  <p>Redirect responses are instances of the Illuminate\Http\RedirectResponse class, and contain the proper headers needed to redirect the user to another URL. There are several ways to generate a RedirectResponse instance. The simplest way is to use the global redirect() helper:</p>

  <pre><code class="language-php">
    Route::get('dashboard', function() {
      return redirect('home/dashboard');
    });
  </code></pre>

  <p>Sometimes you may wish to redirect the user to their previous location such as when a submitted form is invalid. We do this using the global back() helper function. Since this feature utilizes the session, make sure the route calling the back function is using the web-middleware group or has all of the session middleware applied:</p>

  <pre><code class="language-php">
    Route::get('user/profile', function() {
      // Validate the request

      return back()->withInput();
    });
  </code></pre>

  <h3>Redirecting to Named Routes</h3>

  <p>When you call the redirect helper with no parameters, an instance of Illuminate\Routing\Redirector is returned, allowing you to call any method on the Redirector instance. For example, to generate a RedirectResponse to a named route, we can use the route() method:</p>

  <pre><code class="language-php">
    return redirect()->route('login');
  </code></pre>

  <p>If the route has parameters, we can pass them as the second argument to the route() method:</p>

  <pre><code class="language-php">
    // for a route with the following URI: profile/{id}

    return redirect()->route('profile', ['id' => 1]);
  </code></pre>

  <h4>Populating Parameters via Eloquent Models</h4>

  <p>If redirecting to a route with an ID parameter that is being populated from an Eloquent model, we can simply pass the model itself. The ID will be extracted automatically:</p>

  <pre><code class="language-php">
    // for a route with the following URI: profile/{id}

    return redirect()->route('profile', [$user]);
  </code></pre>

  <p>To customize the value that is placed in the route parameter, we can override the getRouteKey method on the Eloquent model:</p>

  <pre><code class="language-php">
    /**
     * Get the value of the model's route key.
     *
     * @return mixed
     */
    public function getRouteKey()
    {
        return $this->slug;
    }
  </code></pre>

  <h3>Redirecting to Controller Actions</h3>

  <p>We can also generate redirects to controller actions. To do this, we pass the controller and action name to the action() method. Remember, we do not need to specify the full namespace to the controller since Laravel's RouteServiceProvider will automatically set the base controller namespace:</p>

  <pre><code class="language-php">
    return redirect()->action('HomeController@index');
  </code></pre>

  <p>If the controller route requires parameters, we can pass them as the second argument to the action method:</p>

  <pre><code class="language-php">
    return redirect()->action(
    'UserController@profile', ['id' => 1]
    );
  </code></pre>

  <h3>Redirecting with Flashed Session Data</h3>

  <p>Redirecting to a new URL, and flashing data to the session, are usually done at the same time. This is usually done after successfully performing an action when you flash a success message to the session. For convenience, we can create a RedirectResponse instance and flash data to the session in a single, fluent method chain:</p>

  <pre><code class="language-php">
    Route::post('user/profile', function() {
      // Update the user's profile

      return redirect('dashboard')->with('status', 'Profile updated!');
    });
  </code></pre>

  <p>After the user is redirected, we can display the flashed message from the session. Using blade syntax:</p>

  <pre><code class="language-php">
    @ if (session('status'))
        div class="alert alert-success">
            { { session('status') } }
        /div>
    @ endif
  </code></pre>

  <h2>Other Response Types</h2>

  <p>The response() helper may be used to generate other types of response instances. When the response() helper is called without arguments, an implementation of the Illuminate\Contracts\Routing\ResponseFactory contract is returned. This contract provides several helpful methods for generating responses.</p>

  <h3>View Responses</h3>

  <p>If we need control over the response's status and headers but also need to return a view as the response's content, we can use the view() method:</p>

  <pre><code class="language-php">
    return response()
      ->view('hello', $data, 200)
      ->header('Content-Type', $type)
  </code></pre>

  <p>Of course, if we don't need to pass a custom HTTP status code or custom headers, we can use the global view() helper function.</p>

  <h3>JSON Responses</h3>

  <p>The json() method will automatically set the Content-Type header to application/json, as well as convert the given array to JSON using the json_encode() PHP function:</p>

  <pre><code class="language-php">
    return response()->json([
    'name' =>'Abigail',
    'state' => 'CA'
    ]);
  </code></pre>

  <p>To create a JSONP response, we can use the json() method in combination with the withCallback() method:</p>

  <pre><code class="language-php">
    return response()
      ->json(['name' => 'Abigail', 'state' => 'CA'])
      ->withCallback($request->input('callback'));
  </code></pre>

  <h3>File Downloads</h3>

  <p>The download() method can be used to generate a response that forces the user's browser to download the file at the given path. The download() method accepts a file name as the second argument to the method, which will determine the file name that is seen by the user downloading the file. Finally we can pass an array of HTTP headers as the third argument to the method:</p>

  <pre><code class="language-php">
    return response()->download($pathToFile);

    return response()->download($pathToFile, $name, $headers);

    return response()->download($pathToFile)->deleteFileAfterSend(true);
  </code></pre>

  <div class="w3-panel w3-border-blue w3-leftbar w3-pale-blue">
    <p>Symphony HttpFoundation, which manages file downloads, requires the file being downloaded to have an ASCII file name.</p>
  </div>

  <h3>File Responses</h3>

  <p>The file() method may be used to display a file, such as an image or PDF, directly in the user's browser instead of initiating a download. This method accepts the path to the file as its first argument, and an array of headers as its second argument:</p>

  <pre><code class="language-php">
    return response()->file($pathToFile);

    return response()->file($pathToFile, $headers);
  </code></pre>

  <h2>Response Macros</h2>

  <p>To define a custom response that can be re-used in a variety of routes and controllers, we can use the macro() method on the Response facade. For example, from a service provider's boot() method:</p>

  <pre><code class="language-php">
    use Illuminate\Support\ServiceProvider;
    use Illuminate\Support\Facades\Response;

    class ResponseMacroServiceProvider extends ServiceProvider
    {
        /**
         * Register the application's response macros.
         *
         * @return void
         */
        public function boot()
        {
            Response::macro('caps', function ($value) {
                return Response::make(strtoupper($value));
            });
        }
    }
  </code></pre>

  <p>The macro() function accepts a name as its first argument, and a closure as its second. The macro's closure will be executed when calling the macro name from a ResponseFactory implementation or the response helper:</p>

  <pre><code class="language-php">
    return response()->caps('foo');
  </code></pre>

@endsection
